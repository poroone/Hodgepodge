# OSL七层参考模型   
   1. 7.应用层 http ws ftp ssh rtmp pop3 imap
   2. 6.表示层 处理媒体传输 遗迹ASCII码 图片 音频 视频 ssl进行转换二进制
   3. 5.会话层 会话的id 保持数据的持久性
   4. 4.传输层 tcp/udp tcp比较慢三次握手四次挥手 HTTP协议 ws协议 ssh协议 ftp协议,udp是无连接的 比较快 常用于物联网 电器 直播 视频 DNS(有限使用UDP)
   5. 3.网络层 有了IP地址 可以和全世界进行通讯,回去路由器进行传输数据 递归查找 混淆数据进行发包巴拉巴拉 
   6. 2.数据链路层 组装数据 设备 交换机 Mac地址 xx-xx-xx-xx-xx-xx 不一定是唯一的
   7. 1.物理层 物理设备 光纤(原理 全反射 海市蜃楼 ) 0 1 0 1 0 1 0 1  比特流 双绞线 电线杆 同轴电缆 最终就是电信号 0 1 
# TCP/IP实施模型 四层
   1. 应用层 http ws ftp ssh rtmp pop3 imap
   2. 传输层 tcp/udp tcp比较慢三次握手四次挥手 HTTP协议 ws协议 ssh协议 ftp协议,udp是无连接的 比较快 常用于物联网 电器 直播 视频 DNS(有限使用UDP)
   3. 网络层 有了IP地址 可以和全世界进行通讯,回去路由器进行传输数据 递归查找 混淆数据进行发包巴拉巴拉 
   4. 物理层 物理设备 光纤(原理 全反射 海市蜃楼 ) 0 1 0 1 0 1 0 1  比特流 双绞线 电线杆 同轴电缆 最终就是电信号 0 1 
# 浏览器输入url发生了什么
- TCP的标志位
    1. SYN：简写为S，同步标志位，用于建立会话连接，同步序列号；
    2. ACK： 简写为.，确认标志位，对已接收的数据包进行确认；
    3. FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；
    4. PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
    5. RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；
    6. URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；
1. dns解析 拿到真正的ip
    1. 先从浏览器dns表查找有没有如果有返回ip
    2. 从etc目录下的dns表查找有的话返回ip
    3. 从host表去找 如果有返回ip 
    4. 如果都找不到会发送dns请求
       1. 递归查询 根域名服务器 . 
       2. 顶级域名服务器 com. 
       3. 权威服务器查找baidu.com. 
2. Tcp三次握手
   1. 第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态
    2. 第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态
    3. 第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手
3. http 强缓存和协商缓存
   1. 缓存策略
      2. 内存缓存(redis) (memory cache) 一般缓存在浏览器的内存中 优点就是速度快 缺点就是网页关闭就释放了(一般出现于刷新的时候内存缓存)刷新的时候多一点
      3. 磁盘缓存(mysql) (disk cache) 一般缓存在电脑的磁盘上 缺点是速度比内存缓存满 优点是空间大(一般出现与第一次打开)
   1. 强缓存是 : 没过期 第二次就不会经过服务器了 -200 优先强缓存 ！ 
      1. Cache-Control: max-age 比较新
         1. public 任何服务器都可以缓存 包括代理  常用于cdn
         2. private 仅限于客户端缓存 代理服务器是不行的
         3. max-age 时间戳
         4. no-cache 不走强缓存了
      2. Expires(utc时间): http1.0的字段 有些浏览器不支持了
         1. 设置一个缓存时间 max-age=100 
         2. 没过期就拿浏览器缓存不会请求了
         3. 缓存分为内存缓存和硬盘缓存 状态码是200
   2. 协商缓存 -304
      1. last-modified 配合if-modified-since 
         1. last-modified 设置文件最后的修改日期
         2. if-modified-since 浏览器给我们的 第二次访问浏览会携带这个此段 字段的值就是if-modified
      2. Etag 配合if-none-match(版本 /事件 /hash都可) 
      3. 状态码是304
4. 通过ip拿到html代码
   1. 拿到html代码进行解析
   2. 通过渲染引擎 谷歌 Blink 生成dom树 生成render树 渲染render树
   3. 触发回流 重绘  
      1. 优化回流 重绘(减少页面回流重回)使用document.createFragment 文档碎片 vue3用这个优化了回流重绘
   4. 解析css 生成ast抽象语法树 red会转换成rgb(255,0,0) 
   5. 解析js 使用v8引擎解析
      1. Scaner扫描器,词法分析 语法分析 parse解析成 ast抽象语法树 preParse预编译 然后通过 ignation解释器 转换成字节码(中间码) 通过trunfan 转换成机器码(汇编语言) 运行到cpu中
      2. cpu是基于冯诺依曼体系结构去做的
         1. 冯诺依曼体系是,输入设备(鼠标键盘),输出设备(显示器) 存储器(内存) 运算器(运算的) 控制器(调度中心)
      3. 
5. TCP四次挥手
   1. 第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态

   2. 第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态

   1. 第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

   4. 第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

   - 为什么客户端要等待2MSL？
   - 主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。
  